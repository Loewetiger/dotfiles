From ad5cb96a23644257ce461f7f8ba95f9152f535a7 Mon Sep 17 00:00:00 2001
From: Loewetiger <loewetiger@tuta.io>
Date: Fri, 3 Oct 2025 20:35:34 +0200
Subject: [PATCH 4/4] Try to make parsing logic more readable

---
 harper-ls/src/jjdescription_parser.rs | 108 +++++++++++---------------
 1 file changed, 45 insertions(+), 63 deletions(-)

diff --git a/harper-ls/src/jjdescription_parser.rs b/harper-ls/src/jjdescription_parser.rs
index 317805cc..a12ee69c 100644
--- a/harper-ls/src/jjdescription_parser.rs
+++ b/harper-ls/src/jjdescription_parser.rs
@@ -25,88 +25,70 @@ impl Parser for JjdescriptionParser {
 
 struct JjdescriptionTokenizer<'a> {
     chars: &'a [char],
-    pos: usize,
 }
 
 impl<'a> JjdescriptionTokenizer<'a> {
     fn new(chars: &'a [char]) -> Self {
-        Self { chars, pos: 0 }
+        Self { chars }
     }
 
-    fn starts_with_jj(&self) -> bool {
-        self.pos + 2 < self.chars.len()
-            && self.chars[self.pos] == 'J'
-            && self.chars[self.pos + 1] == 'J'
-            && self.chars[self.pos + 2] == ':'
+    fn is_jj_at(&self, pos: usize) -> bool {
+        self.chars.get(pos..pos + 3) == Some(&['J', 'J', ':'])
     }
 
-    fn find_line_end(&self) -> usize {
-        for i in self.pos..self.chars.len() {
-            if self.chars[i] == '\n' {
-                return i;
+    fn find_next_line(&self, start: usize) -> Option<usize> {
+        self.chars
+            .get(start..)
+            .and_then(|slice| slice.iter().position(|&c| c == '\n'))
+            .map(|pos| start + pos)
+    }
+
+    fn find_newline_before_next_jj(&self, start: usize) -> Option<usize> {
+        let mut i = start;
+
+        loop {
+            // Find next newline
+            i += self.chars[i..].iter().position(|&c| c == '\n')?;
+            let next = i + 1;
+            // Note that comments in jjdescription are only
+            // valid if they are at the start of a line:
+            // "JJ:" valid comment
+            // " JJ:" not a valid comment
+            if next < self.chars.len() && self.is_jj_at(next) {
+                return Some(i);
             }
+            i = next;
         }
-        self.chars.len() - 1
     }
 
-    fn find_next_jj_line(&self) -> Option<usize> {
-        let mut i = self.pos;
-
-        // Check if we're at the start of a line
-        let mut at_line_start = i == 0 || (i > 0 && self.chars[i - 1] == '\n');
+    fn parse<P: Parser>(&self, parser: &P) -> Vec<Token> {
+        let mut i = 0;
+        let mut tokens = vec![];
 
         while i < self.chars.len() {
-            if at_line_start && i + 2 < self.chars.len() {
-                if self.chars[i] == 'J' && self.chars[i + 1] == 'J' && self.chars[i + 2] == ':' {
-                    return Some(i);
-                }
-            }
+            if self.is_jj_at(i) {
+                // This is a "JJ:" line
+                let start = i;
+                let newline_idx = self.find_next_line(i);
 
-            // Move to next character
-            if self.chars[i] == '\n' {
-                at_line_start = true;
+                tokens.push(Token::new(
+                    Span::new(start, newline_idx.unwrap_or(self.chars.len())),
+                    TokenKind::Unlintable,
+                ));
+
+                i = newline_idx.map_or(self.chars.len(), |idx| idx + 1);
             } else {
-                at_line_start = false;
-            }
-            i += 1;
-        }
+                // This is a non-"JJ:" line (or multiple lines until next "JJ:")
+                let start = i;
+                let newline_idx = self.find_newline_before_next_jj(i);
 
-        None
-    }
-
-    fn parse(&mut self, text_parser: &dyn Parser) -> Vec<Token> {
-        let mut tokens = Vec::new();
-
-        while self.pos < self.chars.len() {
-            // Check if current position is at the start of a line
-            let at_line_start = self.pos == 0 || (self.pos > 0 && self.chars[self.pos - 1] == '\n');
-
-            if at_line_start && self.starts_with_jj() {
-                // Found a JJ line
-                let start = self.pos;
-                let end = self.find_line_end();
-                tokens.push(Token::new(Span::new(start, end + 1), TokenKind::Unlintable));
-                self.pos = end + 1; // Move past the newline
-            } else {
-                let start = self.pos;
-
-                // Skip current position to avoid immediate match
-                self.pos += 1;
-
-                let end = match self.find_next_jj_line() {
-                    Some(next_jj) => next_jj - 1, // Stop before the next JJ line
-                    None => self.chars.len() - 1, // Go to end of slice
-                };
-
-                if end >= start {
-                    let base = text_parser.parse(&self.chars[start..end + 1]);
-                    for mut english_token in base {
-                        english_token.span.push_by(start);
-                        tokens.push(Token::new(english_token.span, english_token.kind));
-                    }
+                let slice = &self.chars[start..newline_idx.unwrap_or(self.chars.len())];
+                for mut token in parser.parse(slice) {
+                    token.span.push_by(start);
+                    tokens.push(token);
                 }
 
-                self.pos = end + 1;
+                i = newline_idx.map_or(self.chars.len(), |idx| idx + 1);
             }
         }
 
-- 
2.51.0

